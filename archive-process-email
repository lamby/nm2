#!/usr/bin/python3

"""
Dispatch an email to the right mailbox
"""

from __future__ import print_function
from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals
import sys
import re
import shutil
import os
import os.path
from email.parser import BytesHeaderParser
from email.utils import getaddresses

VERSION="0.1"
DEFAULT_DESTDIR = "/srv/nm.debian.org/mbox/applicants"

class AddressError(Exception):
    pass

class LookupError(Exception):
    pass

# Function that processes query strings before going to the database. It is
# overridden to a replace of %s to ? when using sqlite.
Q = lambda s: s

class umask_override(object):
    """
    Context manager that temporarily overrides the umask during its lifetime
    """
    def __init__(self, umask):
        self.new_umask = umask
        self.old_umask = None

    def __enter__(self):
        # Set umask
        self.old_umask = os.umask(self.new_umask)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Restore umask
        os.umask(self.old_umask)
        return False


class Dispatcher(object):
    re_dest = re.compile("^archive-(.+)@nm.debian.org$")

    def __init__(self, infd, destdir=DEFAULT_DESTDIR):
        self.destdir = destdir
        self.infd = infd
        self._db = None

        # Parse the header only, leave the body in the input pipe
        self.msg = BytesHeaderParser().parse(self.infd)

        # History of lookup attempts
        self.lookup_attempts = []

    @property
    def db(self):
        if self._db is None:
            try:
                import psycopg2
                self._db = psycopg2.connect("service=nm user=nm")
            except:
                import sqlite3
                self._db = sqlite3.connect("data/db-used-for-development.sqlite")
                global Q
                Q = lambda s: s.replace("%s", "?").replace("true", "1")
        return self._db

    def log_lookup(self, msg):
        self.lookup_attempts.append(msg)
        self.msg.add_header("NM-Archive-Lookup-History", msg)

    def get_dest_key(self):
        """
        Lookup the archive-(?P<key>.+) destination key in the Delivered-To mail
        header, extract the key and return it.

        Raises LookupError if no parsable Delivered-To header is found.
        """
        dests = self.msg.get_all("Delivered-To")
        if dests is None:
            raise LookupError("No Delivered-To header found")

        for dest in dests:
            if dest == "archive@nm.debian.org":
                self.log_lookup("ignoring {} as destination".format(dest))
                continue

            mo = self.re_dest.match(dest)
            if mo is None:
                self.log_lookup("delivered-to '{}' does not match any known format".format(dest))
                continue

            self.log_lookup("found destination key: '%s'" % mo.group(1))
            return mo.group(1)

        raise LookupError("No valid Delivered-To headers found")

    def deliver_to_failsafe(self, reason=None, exc=None):
        """
        Deliver the message to the failsafe mailbox
        """
        if reason is None:
            reason = "exception %s: %s" % (exc.__class__.__name__, str(exc))
        self.msg["NM-Archive-Failsafe-Reason"] = reason

        with umask_override(0o037) as uo:
            with open(os.path.join(self.destdir, "failsafe.mbox"), "ab") as out:
                out.write(self.msg.as_string(True).encode("utf-8"))
                out.write(b"\n")
                shutil.copyfileobj(self.infd, out)

    def deliver_to_archive_key(self, arc_key):
        with umask_override(0o037) as uo:
            with open(os.path.join(self.destdir, "%s.mbox" % arc_key), "ab") as out:
                out.write(self.msg.as_string(True).encode("utf-8"))
                out.write(b"\n")
                shutil.copyfileobj(self.infd, out)

    def archive_key_from_dest_key(self, dest_key):
        cur = self.db.cursor()
        query = """
        SELECT pr.archive_key
          FROM person p
          JOIN process pr ON pr.person_id = p.id
         WHERE pr.is_active IS TRUE
        """

        if '=' in dest_key:
            # Lookup email
            email = dest_key.replace("=", "@")
            self.log_lookup("lookup by email '%s'" % email)
            cur.execute(Q(query + "AND p.email=%s"), (email,))
        else:
            # Lookup uid
            self.log_lookup("lookup by uid '%s'" % dest_key)
            cur.execute(Q(query + "AND p.uid=%s"), (dest_key,))

        # Get the person ID
        arc_key = None
        for i, in cur:
            arc_key = i

        if arc_key is None:
            raise LookupError("invalid destination key in Delivered-To address: '%s'" % dest_key)

        return arc_key

    def get_arc_key(self):
        dest_key = self.get_dest_key()
        return self.archive_key_from_dest_key(dest_key)


def main():
    from optparse import OptionParser

    class Parser(OptionParser):
        def __init__(self, *args, **kwargs):
            OptionParser.__init__(self, *args, **kwargs)

        def error(self, msg):
            sys.stderr.write("%s: error: %s\n\n" % (self.get_prog_name(), msg))
            self.print_help(sys.stderr)
            sys.exit(2)

    parser = Parser(usage="usage: %prog [options]",
                    version="%prog "+ VERSION,
                    description="Dispatch NM mails Cc-ed to the archive address")
    parser.add_option("--dest", action="store", default=DEFAULT_DESTDIR, help="destination directory (default: %default)")
    parser.add_option("--dry-run", action="store_true", help="print destinations instead of delivering mails")
    (opts, args) = parser.parse_args()

    dispatcher = Dispatcher(sys.stdin.buffer, destdir=opts.dest)
    if opts.dry_run:
        msgid = dispatcher.msg.get("message-id", "(no message id)")
        try:
            arc_key = dispatcher.get_arc_key()
            print(msgid, arc_key)
            return 0
        except Exception as e:
            print(msgid, "failsafe")
            return 1
    else:
        try:
            arc_key = dispatcher.get_arc_key()
            dispatcher.deliver_to_archive_key(arc_key)
            return 0
        except Exception as e:
            dispatcher.deliver_to_failsafe(exc=e)
            return 1

if __name__ == "__main__":
    sys.exit(main())

